<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rune Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="2_getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="3_concepts.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_1_variables.html"><strong aria-hidden="true">3.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="3_2_control_flow.html"><strong aria-hidden="true">3.2.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="3_3_loops.html"><strong aria-hidden="true">3.3.</strong> Loops</a></li><li class="chapter-item expanded "><a href="3_4_pattern_matching.html"><strong aria-hidden="true">3.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="4_types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_1_primitives.html"><strong aria-hidden="true">4.1.</strong> Primitives and References</a></li><li class="chapter-item expanded "><a href="4_2_vectors.html"><strong aria-hidden="true">4.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="4_3_objects.html"><strong aria-hidden="true">4.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="4_4_tuples.html"><strong aria-hidden="true">4.4.</strong> Tuples</a></li></ol></li><li class="chapter-item expanded "><a href="5_structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li class="chapter-item expanded "><a href="6_enums.html"><strong aria-hidden="true">6.</strong> Enums</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_1_try_operator.html"><strong aria-hidden="true">6.1.</strong> Try operator</a></li></ol></li><li class="chapter-item expanded "><a href="7_async.html"><strong aria-hidden="true">7.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="8_closures.html"><strong aria-hidden="true">8.</strong> Closures</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rune Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome the <em>The Rune Programming Language</em>, a reference guide about Rune.</p>
<p>Rune is an embeddable dynamic programming language that runs on a stack machine.
Similar to <a href="http://www.lua.org/">Lua</a>.</p>
<p>The goal of Rune is to reimagine Rust as a dynamic programming language.
Trying to copy as many concepts as possible, and remixing ones which do not
translate into something which feels familiar.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The first thing you need to learn about in Rune is the <code>dbg</code> function.
This is used to &quot;debug&quot; whatever values are provided to it, and can be used
by programmers in any environment to look at values in their program.</p>
<p>The <code>dbg</code> function output information on its arguments to stdout, but its exact
behavior is specific to the environment in which Rune is used.</p>
<p>When embedded into a larger application it might not be suitable to output to
stdout, so it might for example have been configured to write to a log file
instead.</p>
<p>Rune does also provide a <code>print</code> and <code>println</code> functions which can be used to
write directly to stdout, but these might be disabled if they're not suitable
for the environment used.</p>
<p>For now, lets use <code>println</code> when printing to stdout.</p>
<pre><code class="language-rust noplaypen">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<p>You can execute this with the <code>rune-cli</code>, a commandline interface to the rune
language that comes with this project.</p>
<p>After each code snipped there will be a terminal showing the command used, and
its output.
Like this:</p>
<pre><code class="language-text">$&gt; cargo run -- scripts/hello_world.rn
Hello World
== Unit (412.2µs)
</code></pre>
<p>At the end of the script you see this rather odd looking line:</p>
<pre><code class="language-text">== Unit (412.2µs)
</code></pre>
<p>This simply means that the script evaluated to a unit, or a <code>()</code>.
And that the execution took <code>412</code> microseconds.</p>
<blockquote>
<p>Cool Hint:
Any function that doesn't have a return value returns a unit.</p>
</blockquote>
<p>So now you know how to run Rune scripts. Well done!</p>
<p>Let's move on with the rest of the book.</p>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter covers common concepts that appear in almost all programming
languages, and how they work in Rune.</p>
<p>These should be familiar to anyone who's used an imperative programming
languages before.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>Variables in Rune are defined using the <code>let</code> keyword.
In contrast to Rust, all variables in Rune are mutable and do not require a
<code>mut</code> keyword to change.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let x = 5;
    println(`The value of x is: {x}`);
    x = 6;
    println(`The value of x is: {x}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_1/variables.rn
The value of x is: 5
The value of x is: 6
</code></pre>
<h2><a class="header" href="#reference-counting-and-ownership" id="reference-counting-and-ownership">Reference Counting and Ownership</a></h2>
<p>In rune, all variables are reference counted and can be shared across multiple
variables.</p>
<p>This means that all variables in rune have <em>shared ownership</em>.
This means that every variable that points to an object on the stack, points to
<em>the same instance</em> of that object.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`{object.field}`);
    object2.field = 2;
    println(`{object2.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_1/shared_ownership.rn
1
2
== Unit (913.4µs)
</code></pre>
<p>This can potentially cause issues if we call an external function that expects
to take ownership of its arguments.</p>
<p>We say that functions like these <em>move</em> their argument, and if we try to use a
variable which has been moved the virtual machine will error.</p>
<blockquote>
<p>Note: Below we use the <code>drop</code> function, which is a built-in function that will
take its argument and free it.</p>
</blockquote>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);
    println(`field: {object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_1/take_argument.rn
field: 1
error: virtual machine error
  ┌─ scripts/book/3_1/take_argument.rn:6:22
  │
6 │     println(`field: {object.field}`);
  │                      ^^^^^^^^^^^^ failed to access value: not accessible for shared access

</code></pre>
<p>If you need to, you can test if a variable is still accessible with
<code>is_readable</code> and <code>is_writable</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);

    if is_readable(object) {
        println(`field: {object.field}`);
    } else {
        println(&quot;object is no longer readable 😢&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_1/is_readable.rn
field: 1
object is no longer readable 😢
</code></pre>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Rune supports your typical forms of control flow.</p>
<h2><a class="header" href="#return-keyword" id="return-keyword"><code>return</code> Keyword</a></h2>
<p>The <code>return</code> keyword allows for returning from the current function.
If specified without an argument, the function will return a unit <code>()</code>.</p>
<p>The last statement in a function is known as an <em>implicit return</em>, and will be
what the function returns by default unless a <code>return</code> is specified.</p>
<pre><code class="language-rust noplaypen">fn foo(n) {
    if n &lt; 1 {
        return &quot;less than one&quot;;
    }

    &quot;something else&quot;
}

fn main() {
    println(foo(0)) // =&gt; outputs: &quot;less than one&quot;
    println(foo(10)); // =&gt; outputs: &quot;something else&quot;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_2/numbers_game.rn
less than one
something else
== Unit (3.8608ms)
</code></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> Expressions</a></h2>
<p>If expressions allow you to provide a condition with one or more code branches.
If the condition is <code>true</code>, the provided block of code will run.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;The number *is* smaller than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_2/conditional.rn
The number *is* smaller than 5
== Unit (5.108ms)
</code></pre>
<p>Optionally, we can add another branch under <code>else</code>, which will execute in case
the condition is false.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else {
        println(&quot;the number is 5 or bigger&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_2/conditional_else.rn
the number is smaller than 5
== Unit (196.1µs)
</code></pre>
<p>We can also add an arbitrary number of <code>else if</code> branches, which allow us to
specify many different conditions.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else if number == 5 {
        println(&quot;the number is exactly 5&quot;);
    } else {
        println(&quot;the number is bigger than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_2/conditional_else_ifs.rn
the number is smaller than 5
== Unit (227.9µs)
</code></pre>
<p>Do note however that if you have <em>many</em> conditions, it might be cleaner to use
a <code>match</code>.</p>
<p>This will be covered in a later section, but here is a sneak peek:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    match number {
        n if n &lt; 5 =&gt; {
            println(&quot;the number is smaller than 5&quot;);
        }
        5 =&gt; {
            println(&quot;the number is exactly 5&quot;);
        }
        n =&gt; {
            println(&quot;the number is bigger than 5&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_2/first_match.rn
the number is smaller than 5
== Unit (124.2µs)
</code></pre>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>Loops are a fundamental building block common to many programming languages.
This is no exception in Rune.
Loops allow you to execute a block of code until a specific condition is
reached, which can be a powerful tool for accomplishing programming tasks.</p>
<h2><a class="header" href="#break-keyword" id="break-keyword"><code>break</code> Keyword</a></h2>
<p>Every loop documented in this section can be <em>terminated early</em> using the
<code>break</code> keyword.</p>
<p>When Rune encounters a break, it will immediately jump out of the loop it is
currently in and continue running right after it.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let value = 0;

    while value &lt; 100 {
        if value &gt;= 50 {
            break;
        }

        value = value + 1;
    }

    println(`The value is {value}`); // =&gt; The value is 50
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_3/while_loop.rn
The value is 50
== Unit (501.1µs)
</code></pre>
<h2><a class="header" href="#loop-expressions" id="loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> keywords builds the most fundamental form of loop in Rune.
One that repeats unconditionally forever, until it is exited using another
control flow operator like a <code>break</code> or a <code>return</code>.</p>
<pre><code class="language-rust noplaypen">use time::Duration;

fn main() {
    loop {
        println(&quot;loop forever&quot;);
        time::delay_for(Duration::from_secs(1)).await;
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_3/loop_forever.rn
Hello forever!
Hello forever!
Hello forever!
...
</code></pre>
<blockquote>
<p>Hint: If you want this one to end, you're gonna have to kill it with <code>CTRL+C</code>.</p>
</blockquote>
<p>We're also using an asynchronous function called <code>delay_for</code> above to avoid
spamming our terminals too much.
Well talk more about these in a later section.</p>
<p>When broken out of, loops produce the value provided as an argument to the
<code>break</code> keyword.
By default, this is simply a unit <code>()</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let counter = 0;

    let total = loop {
        counter = counter + 1;

        if counter &gt; 10 {
            break counter;
        }
    };

    println(`The final count is: {total}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_3/loop_break.rn
The final count is: 11
== Unit (281.5µs)
</code></pre>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<p>In this section we will be discussing <em>Pattern Matching</em>.</p>
<p>Pattern matching is a flexible mechanism that allows for validating the
structure and type of the argument, while also destructing it to give easy
access to what you need.</p>
<p>Below are some examples of its common uses to match on branch conditions:</p>
<pre><code class="language-rust noplaypen">fn match_input(n) {
    match n {
        1 =&gt; println(&quot;The number one.&quot;),
        n if n is int =&gt; println(`Another number: {n}.`),
        [1, 2, n, ..] =&gt; println(`A vector starting with one and two, followed by {n}.`),
        &quot;one&quot; =&gt; println(&quot;One, but this time as a string.&quot;),
        _ =&gt; println(&quot;Something else. Can I go eat now?&quot;),
    }
}

fn main() {
    match_input(1);
    match_input(2);
    match_input([1, 2, 42, 84]);
    match_input(&quot;one&quot;);
    match_input(#{field: 42});
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_4/big_match.rn
The number one.
Another number: 2.
A vector starting with one and two, followed by 42.
One, but this time as a string.
Something else. Can I go eat now?
== Unit (5.691ms)
</code></pre>
<p>We will be covering each of these variants in detail in the coming sections.</p>
<h2><a class="header" href="#matching-literals" id="matching-literals">Matching Literals</a></h2>
<p>Literals are the simplest form of matching. Where we test if the branch is
exactly equal to a literal.</p>
<p>Literals take a number of form:</p>
<ul>
<li>A literal unit, simply <code>()</code>.</li>
<li>A literal boolean, like <code>true</code> or <code>false</code>.</li>
<li>A literal character, like <code>'a'</code> or <code>'あ'</code>.</li>
<li>A literal integer, like <code>42</code>.</li>
<li>A string, like <code>&quot;Steven Universe&quot;</code>.</li>
<li>A vector, like the numbers <code>[4, 8, 15, 16, 23, 42]</code> or the empty vector <code>[]</code>.</li>
<li>A tuple, like <code>(&quot;Steven Universe&quot;, 42)</code>.</li>
<li>An object, like the numbers <code>{&quot;name&quot;: &quot;Steven Universe&quot;}</code> or the empty <code>{}</code>.</li>
</ul>
<p>Finally, literals can be <em>any</em> combination of the above.
Even <code>{&quot;items&quot;: [&quot;Sword&quot;, &quot;Bow&quot;, &quot;Axe&quot;]}</code> is a literal that can be matched over.</p>
<h2><a class="header" href="#match-bindings" id="match-bindings">Match Bindings</a></h2>
<p>In a pattern, every literal value can also be replaced with an ignore directive
or a binding.</p>
<p>The ignore directive looks like an underscore <code>_</code>, which tells rune to <em>ignore</em>
the value, allowing it to have any value.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, 2] =&gt; println(&quot;Second item in vector is 2.&quot;),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_4/ignore.rn
Second item in vector is 2.
== Unit (281.3µs)
</code></pre>
<p>In contrast to ignoring, we cal also <em>bind</em> the value to a variable that is then
in scope of the match arm.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, b] =&gt; println(`Second item in vector is {b}.`),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_4/bind.rn
Second item in vector is 2.
== Unit (6.25ms)
</code></pre>
<p>Here are some more examples:</p>
<ul>
<li><code>[_, a, b]</code> which will ignore the first, but then capture the second and third
element in the vector.</li>
<li><code>{&quot;name&quot;: name}</code> will capture the <code>name</code> value out of the specified object.</li>
</ul>
<p>Finally we can also add the sequence <code>..</code> to ask Rune to <em>ignore</em> any additional
values in a collection that might be present when matching a vector or an
object.</p>
<pre><code class="language-rust noplaypen">fn describe_car(car) {
    match car {
<span class="boring">        {&quot;make&quot;: year, ..} if year &lt; 1950 =&gt; &quot;What, where did you get that?&quot;,
</span><span class="boring">        {&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: year, ..} if year &gt;= 2000 =&gt; &quot;Pretty fast!&quot;,
</span>        _ =&gt; &quot;Can't tell 😞&quot;,
    }
}

fn main() {
    println(describe_car(#{&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: 2000}));
    println(describe_car(#{&quot;model&quot;: &quot;Honda&quot;, &quot;make&quot;: 1980}));
    println(describe_car(#{&quot;model&quot;: &quot;Volvo&quot;, &quot;make&quot;: 1910}));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3_4/fast_cars.rn
Pretty fast!
Can't tell 😞
What, where did you get that?
== Unit (5.3533ms)
</code></pre>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Types in Rune are identified uniquely by their <em>path</em>.
A path is a scope-separated identifier, like <code>std::float</code>.
This identifies a type object.</p>
<p>These can be used to perform basic type checking, like this:</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    assert(() is unit, &quot;units should be units&quot;);
    assert(true is bool, &quot;bools should be bools&quot;);
    assert('a' is char, &quot;chars should be chars&quot;);
    assert(b'a' is byte, &quot;bytes should be bytes&quot;);
    assert(42 is int, &quot;integers should be integers&quot;);
    assert(42.1 is float, &quot;floats should be floats&quot;);
    assert(&quot;hello&quot; is String, &quot;strings should be strings&quot;);
    assert(#{&quot;hello&quot;: &quot;world&quot;} is Object, &quot;objects should be objects&quot;);
    assert([&quot;hello&quot;, &quot;world&quot;] is Vec, &quot;vectors should be vectors&quot;);
}
</code></pre>
<p>Conversely, the type check would fail if it's not valid:</p>
<pre><code class="language-text">error: virtual machine error
  ┌─ .\scripts\book\4_bad_type_check.rn:4:5
  │
4 │     assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
  │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  │     │
  │     virtual machine error
  │     assertion failed: vectors should be strings
  │     error in user-defined function
</code></pre>
<p>So this allows us to determine which type is which and act accordingly:</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4/type_check.rn
n is a String
n is a vector
n is unknown
== Unit (1.0544ms)
</code></pre>
<p>A tighter way to accomplish this could be by using pattern matching:</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4/type_check.rn
n is a String
n is a vector
n is unknown
== Unit (1.0544ms)
</code></pre>
<h1><a class="header" href="#primitives-and-references" id="primitives-and-references">Primitives and References</a></h1>
<p>Primitives are values stored immediately on the stack.
In Rust terminology, these types are <code>Copy</code>, so reassigning them to different
values will create distinct copies of the underlying value.</p>
<p>The primitives available in rune are:</p>
<ul>
<li>the unit <code>()</code>.</li>
<li>booleans, <code>true</code> and <code>false</code>.</li>
<li>bytes, like <code>b'\xff'</code>.</li>
<li>characters, like <code>'今'</code>.</li>
<li>integers, like <code>42</code>.</li>
<li>floats, like <code>3.1418</code>.</li>
</ul>
<p>You can see that these bytes are <code>Copy</code>, because assigning them to a different
variable will cause a separate copy of the variable to be used.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = 1;
    let b = a;
    a = 2;
    println(`{a}`);
    println(`{b}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/copy.rn
2
1
== Unit (691.3µs)
</code></pre>
<p>In contrast, other types like <em>strings</em> are stored by reference on the stack.</p>
<p>Assigning them to a different variable will only copy the reference and increase
its reference count, but they point to the same underlying data.
As shown here:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = String::from_str(&quot;Hello&quot;);
    let b = a;
    a.push_str(&quot; World&quot;);
    println(a);
    println(b);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/primitives.rn
Hello World
Hello World
== Unit (9.7406ms)
</code></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>A vector is a native data structure of Rune which is a dynamic list of values.
A vector isn't typed, and can store <em>any</em> rune values.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = Vec::new();
    values.push(&quot;Hello&quot;);
    values.push(42);

    while let Some(v) = values.pop() {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/vectors.rn
0 = Integer(42)
0 = StaticString(&quot;Hello&quot;)
== Unit (7.5299ms)
</code></pre>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>Objects are anonymous hash maps, which support defining arbitrary string keys.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = #{};
    values[&quot;first&quot;] = &quot;bar&quot;;
    values[&quot;second&quot;] = 42;

    dbg(values[&quot;first&quot;]);
    dbg(values.second);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/objects.rn
0 = StaticString(&quot;bar&quot;)
0 = Integer(42)
== Unit (6.1466ms)
</code></pre>
<p>These are useful because they allow their data to be specified dynamically,
which is exactly the same use case as storing unknown JSON.</p>
<p>One of the largest motivations for <em>Rune</em> to have anonymous objects is so that
we can handle JSON with an unknown structure.</p>
<pre><code class="language-rust noplaypen">fn get_commits(repo, limit) {
    let limit = limit.unwrap_or(10);

    let client = http::Client::new();
    let request = client.get(`https://api.github.com/repos/{repo}/commits`).await?;
    let response = request.header(&quot;User-Agent&quot;, &quot;Rune&quot;).send().await?;
    let text = response.text().await?;
    let json = json::from_string(text)?;

    let commits = Vec::new();
    let count = 0;

    for entry in json {
        commits.push(entry.sha);

        if count &gt;= limit {
            break;
        }

        count += 1;
    }

    commits
}

fn main() {
    for commit in get_commits(&quot;rune-rs/rune&quot;, Some(5)) {
        println(commit);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/json.rn
9c4bdaf194410d8b2f5d7f9f52eb3e64709d3414
06419f2580e7a18838f483321055fc06c0d75c4c
cba225dad143779a0a9543cfb05cde9710083af5
15133745237c014ff8bae53d8ff8f3c137c732c7
39ac97ab4ebe26118e807eb91c7656ab95b1fcac
3f6310eeeaca22d0373cc11d8b34d346bd12a364
== Unit (331.3324ms)
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples in Rune are a fixed-size sequences of values.
Like all other containers in Rune, tuples can contains any values.</p>
<p>In fact, they can even change the <em>type</em> of the values stored in them, if
needed.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = (&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;);
    dbg(values)

    values.2 = &quot;Don't&quot;;
    values.3 = &quot;!&quot;;
    dbg(values)
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/tuple_masquerade.rn
0 = Tuple(Shared { access: fully accessible, count: 2, data: [StaticString(&quot;Now&quot;), StaticString(&quot;You&quot;), StaticString(&quot;See&quot;), StaticString(&quot;Me&quot;)] })
0 = Tuple(Shared { access: fully accessible, count: 2, data: [StaticString(&quot;Now&quot;), StaticString(&quot;You&quot;), StaticString(&quot;Don\'t&quot;), StaticString(&quot;!&quot;)] })
== Unit (485.6µs)
</code></pre>
<p>The following is a simple example of a function returning a tuple:</p>
<pre><code class="language-rust noplaypen">fn foo() {
    (1, &quot;test&quot;)
}

fn main() {
    dbg(foo());
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/basic_tuples.rn
0 = Tuple(Shared { access: fully accessible, count: 1, data: [Integer(1), StaticString(&quot;test&quot;)] })
== Unit (387.6µs)
</code></pre>
<p>Tuples can also be pattern matched:</p>
<pre><code class="language-rust noplaypen">fn main() {
    match (&quot;test&quot;, 1) {
        (&quot;test&quot;, n) =&gt; {
            dbg(&quot;the first part was a number:&quot;, n);
        }
        _ =&gt; {
            dbg(&quot;matched something we did not understand&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/tuple_patterns.rn
0 = StaticString(&quot;the first part was a number:&quot;)
1 = Integer(1)
== Unit (6.7067ms)
</code></pre>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<p>Structs are like objects, except that they have a predefined structure with a
set of keys that are known at compile time and guaranteed to be defined.</p>
<p>Structs can also, like most types, have an <code>impl</code> block associated with them
which creates instance functions that you can call on an instance of that
struct.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn set_active(self, active) {
        self.active = active;
    }

    fn describe(self) {
        if self.active {
            println(`{self.username} is active`);
        } else {
            println(`{self.username} is inactive`);
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.set_active(true);
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/user_database.rn
setbac is inactive
setbac is active
== Unit (6.2095ms)
</code></pre>
<p>Structs can also be pattern matched, like most types.</p>
<p>But since the fields of a struct are known at compile time, the compiler can
ensure that you're only using fields which are defined.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn describe(self) {
        match self {
            User { username: &quot;setbac&quot;, .. } =&gt; {
                println(&quot;Yep, it's setbac.&quot;);
            }
            User { username, .. } =&gt; {
                println(`Other user: {username}.`);
            }
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.username = &quot;newt&quot;;
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/struct_matching.rn
Yep, it's setbac.
Other user: newt.
== Unit (1.0652ms)
</code></pre>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Rune has support for <em>enumerations</em>.
These allow you to define a type with zero or more <em>variants</em>, where each
variant can hold a distinct set of data.</p>
<p>In a dynamic programming language enums might not seem quite as useful, but it's
important for Rune to support them to have a level of feature parity with Rust.</p>
<p>Even so, in this section we'll explore some cases where enums are useful.</p>
<h2><a class="header" href="#the-option-enum" id="the-option-enum">The <code>Option</code> enum</a></h2>
<p>Rune has native support for <code>Option</code>, the same enum available in Rust that
allows you to represent data that can either be present with <code>Option::Some</code>, or
absent with <code>Option::None</code>.</p>
<pre><code class="language-rust noplaypen">use std::iter::range;

fn count_numbers(limit) {
    let limit = limit.unwrap_or(10);

    for n in range(0, limit) {
        println(`Count: {n}`);
    }
}

fn main() {
    println(&quot;First count!&quot;);
    count_numbers(None);

    println(&quot;Second count!&quot;);
    count_numbers(Some(2));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/6/count_numbers.rn
First count!
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Count: 6
Count: 7
Count: 8
Count: 9
Second count!
Count: 0
Count: 1
== Unit (9.0745ms)
</code></pre>
<p>Using an <code>Option</code> allows us to easily model the scenario where we have an
optional function parameter, with a default fallback value.</p>
<p>In the next section we'll be looking into a control flow construct which gives
<code>Option</code> superpowers.</p>
<p>The try operator.</p>
<h1><a class="header" href="#try-operator" id="try-operator">Try operator</a></h1>
<p>The try operator (<code>?</code>) is a control flow operator which causes a function to
return early in case the value being tried over has a certain value.</p>
<p>For <code>Option</code>, this causes the function to return if it has the <code>Option::None</code>
variant.</p>
<pre><code class="language-rust noplaypen">fn checked_div_mod(a, b) {
    let div = a.checked_div(b)?;
    Some((div, a % b))
}

fn main() {
    if let Some((div, mod)) = checked_div_mod(5, 2) {
        println(`Result: {div}, {mod}`);
    }

    if let Some((div, mod)) = checked_div_mod(5, 0) {
        println(`Result: {div}, {mod}`);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/6_1/basic_try.rn
Result: 2, 1
== Unit (7.4912ms)
</code></pre>
<h1><a class="header" href="#asynchronous-programming" id="asynchronous-programming">Asynchronous Programming</a></h1>
<p>Rune has first class support for Rust-like asynchronous programming.
In this section we'll be briefly covering what asynchronous programming is, and
how it applies to Rune as a dynamic programming language.</p>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>Asynchronous code allows us to run multiple tasks concurrently, and work with
the result of those tasks.</p>
<p>A typical example would be if we want to perform multiple HTTP requests at once:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = http::get(&quot;https://google.com&quot;);
    let b = http::get(&quot;https://amazon.com&quot;);

    loop {
        let res = select {
            res = a =&gt; res?,
            res = b =&gt; res?,
        };

        match res {
            () =&gt; break,
            result =&gt; {
                println(`{result.status()}`);
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/async_http.rn
200 OK
200 OK
== Unit (591.0319ms)
</code></pre>
<p>In the above code we send two requests <em>concurrently</em>. They are both processed
at the same time and we collect the result.</p>
<h2><a class="header" href="#select-blocks" id="select-blocks"><code>select</code> blocks</a></h2>
<p>A fundamental construct of async programming in Rune is the <code>select</code> block.
It enables us to wait on a set of futures at the same time.</p>
<p>A simple example of this is if we were to implement a simple request with a
timeout:</p>
<pre><code class="language-rust noplaypen">struct Timeout;

fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    println(`{result.status()}`);
    Ok(())
}

fn main() {
    if let Err(Timeout) = request(1000) {
        println(&quot;Request timed out!&quot;);
    }

    if let Err(Timeout) = request(4000) {
        println(&quot;Request timed out!&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/async_http_timeout.rn
200 OK
Request timed out!
== Unit (3.2231404s)
</code></pre>
<p>But wait, this is taking three seconds. We're not running the requests
concurrently any longer!</p>
<p>Well, while the request and the <em>timeout</em> is run concurrently, the <code>request</code>
function is run one at-a-time.</p>
<p>To fix this we need two new things: <code>async</code> functions and <code>.await</code>.</p>
<h2><a class="header" href="#async-functions" id="async-functions"><code>async</code> functions</a></h2>
<p><code>async</code> functions are just like regular functions, except that when called they
produce a <code>Future</code>.</p>
<p>In order to get the result of this <code>Future</code> it must be <code>.await</code>-ed.</p>
<pre><code class="language-rust noplaypen">use std::future;

struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    Ok(result)
}

fn main() {
    for result in future::join([request(1000), request(4000)]).await {
        match result {
            Ok(result) =&gt; println(`Result: {result.status()}`),
            Err(Timeout) =&gt; println(&quot;Request timed out!&quot;),
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/async_http_concurrent.rn
Result: 200 OK
Request timed out!
== Unit (2.0028603s)
</code></pre>
<p>If you've been using future in Rust, one thing immediately pops out to you.</p>
<p>We're using <code>.await</code> in a non-<code>async</code> function!</p>
<p>Well, in Rune the virtual machine already comes with a Runtime. Every function
therefore has the ability to <code>.await</code> a future, regardless of if the function
itself is async or not.</p>
<p>In fact, the whole Runtime is asynchronous, but that is for a future, much much
more advanced chapter!</p>
<h1><a class="header" href="#closures" id="closures">Closures</a></h1>
<p>Closures are anonymous functions which closes over their environment.
This means that they capture any variables used inside of the closure, allowing
them to be used when the function is being called.</p>
<pre><code class="language-rust noplaypen">{{#include ../../scripts/8/basic_closure.rn}}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/basic_closure.rn
Result: 4
Result: 3
== Unit (5.4354ms)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
